# Horace - File Storage Gateway Requirements
**Version:** 2.0
**Status:** FINAL - Triplet Consensus Approved
**Created:** 2025-10-05
**Updated:** 2025-10-05 (Incorporated triplet feedback)
**Component Type:** Gateway Service (WebSocket MCP)
**ICCM Architecture Position:** Storage Layer - File Catalog and Organization
**Triplet Consultation:** Correlation ID 97a837cd - Unanimous approval with changes applied

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Component Overview](#2-component-overview)
3. [Architecture](#3-architecture)
4. [Functional Requirements](#4-functional-requirements)
5. [Storage Strategy](#5-storage-strategy)
6. [MCP Tools Specification](#6-mcp-tools-specification)
7. [Metadata Schema](#7-metadata-schema)
8. [Integration Points](#8-integration-points)
9. [Performance Requirements](#9-performance-requirements)
10. [Security and Access Control](#10-security-and-access-control)
11. [Phase 1 Scope (MVP)](#11-phase-1-scope-mvp)
12. [Phase 2+ Future Enhancements](#12-phase-2-future-enhancements)
13. [Technical Specifications](#13-technical-specifications)
14. [Deployment](#14-deployment)
15. [Testing Requirements](#15-testing-requirements)

---

## 1. Executive Summary

### 1.1 Problem Statement

The ICCM ecosystem currently stores files locally on Pharaoh, creating several problems:

1. **No Network Accessibility:** Files generated by ICCM components (Gates ODT documents, Playfair diagrams, Fiedler LLM outputs) are only accessible from the host machine
2. **No Organization:** Files are scattered across component output directories with no central catalog
3. **No Search:** Finding files requires manual directory navigation
4. **No Versioning:** Overwriting files loses previous versions permanently
5. **No Metadata:** File purpose, ownership, and relationships are undocumented
6. **Windows Incompatibility:** Windows machines cannot access Linux-hosted files

### 1.2 Solution Overview

**Horace** is a file storage gateway that provides:

- **Network Storage:** Centralized file storage on Irina's 44TB RAID 5 array
- **Dual Protocol Access:** NFS for Linux containers, SMB/CIFS for Windows workstations
- **File Catalog:** Searchable metadata index of all stored files
- **Automatic Versioning:** Maintains last N versions of each file (configurable, default: 5)
- **MCP Integration:** 6 MCP tools for file registration, search, and organization
- **Component Integration:** All ICCM components (Gates, Playfair, Fiedler) write to Horace-managed storage

### 1.3 Architectural Position

```
┌─────────────────────────────────────────────────────────────┐
│                    ICCM ARCHITECTURE                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Components (Gates, Playfair, Fiedler, etc.)              │
│       │                                                     │
│       ├─ Write files ──────> /mnt/irina_storage/ (NFS)    │
│       └─ Register metadata ─> Horace MCP (ws://9070)      │
│                                    │                        │
│  Horace (File Storage Gateway)    │                        │
│       ├─ Store metadata ──────────> Godot (logs)          │
│       └─ Store file index ────────> Winni (PostgreSQL)     │
│                                                             │
│  Storage Layer:                                             │
│       └─ Irina 44TB RAID 5 (/mnt/storage)                  │
│           ├─ NFS export (Linux clients)                     │
│           └─ Samba/CIFS export (Windows clients)           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Key Principle:** Horace manages **file organization**, not **file transfer**. Files are written directly to mounted storage; Horace provides the catalog layer.

---

## 2. Component Overview

### 2.1 Component Identity

- **Name:** Horace (after Horace Walpole, 18th-century collector and cataloger)
- **Type:** Gateway Service (WebSocket MCP)
- **Port:** 9070 (host), 8070 (container)
- **Network:** `iccm_network` (Docker)
- **Dependencies:** Godot (logging), Winni (PostgreSQL metadata storage), Irina NFS/Samba

### 2.2 Purpose

Horace serves as the **central file catalog and organization layer** for the ICCM ecosystem. It:

1. **Indexes files** stored on network storage with searchable metadata
2. **Tracks versions** of files automatically (last N versions retained)
3. **Organizes files** into collections and categories
4. **Provides discovery** through metadata search
5. **Records provenance** (which component created the file, why, when)
6. **Enables cross-platform access** (Linux NFS + Windows SMB to same storage)

### 2.3 What Horace Is NOT

- **NOT a file transfer protocol** - Files are written directly to mounted storage
- **NOT a content delivery network** - No caching, streaming, or serving of file content
- **NOT a version control system** - Simple version retention, not Git-like branching/merging
- **NOT an access control system** - Phase 1 trusts Docker network isolation (permissions are future)

---

## 3. Architecture

### 3.1 Storage Architecture

**Backend Storage: Irina 44TB RAID 5**
- **Location:** 192.168.1.210:/mnt/storage
- **Filesystem:** ext4 (existing)
- **Capacity:** 44TB usable (RAID 5: 4x 14.6TB drives)
- **Network Protocols:**
  - **NFS v4** - Linux containers (Pharaoh Docker, future Linux machines)
  - **Samba/CIFS** - Windows workstations (desktop access)

**Mount Points:**
- **Linux containers:** `/mnt/irina_storage` (read-write NFS mount)
- **Windows machines:** `\\irina\storage` (network drive, SMB)
- **Single source of truth:** Both protocols access same backend directory

### 3.2 File Storage Layout

```
/mnt/storage/iccm/                    ← Root of ICCM file storage
├── files/                            ← Current versions
│   ├── gates/                        ← Gates-generated documents
│   ├── playfair/                     ← Playfair diagrams
│   ├── fiedler/                      ← Fiedler LLM outputs
│   ├── user/                         ← User-uploaded files
│   └── shared/                       ← Shared/uncategorized
│
├── .horace_versions/                 ← Version history (hidden)
│   ├── <file_id>.v1
│   ├── <file_id>.v2
│   └── ...
│
└── .horace_metadata/                 ← Horace internal (checksums, locks)
```

**File Naming Convention:**
- **Current file:** `/mnt/storage/iccm/files/<component>/<file_id>.<ext>`
- **File ID:** UUID-based (e.g., `a1b2c3d4-e5f6-7890-abcd-ef1234567890.odt`)
- **Versions:** `/mnt/storage/iccm/.horace_versions/<file_id>.v<N>`

### 3.3 Component Architecture

**Horace Container:**
```
┌─────────────────────────────────────────┐
│  Horace Container (horace-mcp)          │
├─────────────────────────────────────────┤
│  ┌─────────────────────────────────┐   │
│  │  WebSocket MCP Server (8070)    │   │
│  │  - 6 MCP tools                  │   │
│  │  - Health check endpoint        │   │
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │  File Indexer                   │   │
│  │  - Scan /mnt/irina_storage      │   │
│  │  - Compute checksums (SHA256)   │   │
│  │  - Track file changes           │   │
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │  Version Manager                │   │
│  │  - Create .vN on updates        │   │
│  │  - Prune old versions (keep 5)  │   │
│  │  - Restore from version         │   │
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │  Metadata Store Client          │   │
│  │  - PostgreSQL (Winni) via       │   │
│  │    asyncpg connection pool      │   │
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │  Godot Logger Client            │   │
│  │  - MCP-based logging to Godot   │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
         │
         ├─ Volume Mount: /mnt/irina_storage (NFS)
         ├─ Database: Winni @ 192.168.1.210
         └─ Logging: Godot ws://godot-mcp:9060
```

---

## 4. Functional Requirements

### 4.1 File Registration

**REQ-FR-001: File Registration**
- **Description:** Components register files with Horace after writing to storage
- **Input:** File path, metadata (owner, purpose, tags, etc.)
- **Output:** File ID (UUID), confirmation
- **Behavior:**
  1. Verify file exists at provided path
  2. Compute SHA256 checksum
  3. Extract file metadata (size, MIME type, created timestamp)
  4. Store in PostgreSQL `horace_files` table
  5. Log registration event to Godot
  6. Return file ID for future reference

**REQ-FR-002: Automatic File Discovery**
- **Description:** Horace can scan storage and auto-register untracked files
- **Trigger:** Manual tool call OR scheduled scan (Phase 2)
- **Behavior:**
  1. Walk `/mnt/irina_storage/files/` directory tree
  2. Identify files not in PostgreSQL index
  3. Register with default metadata (component inferred from path)
  4. Report number of files discovered

### 4.2 File Versioning

**REQ-FR-003: Automatic Versioning**
- **Description:** Maintain last N versions when file is updated
- **Default:** N=5 (configurable via environment variable `HORACE_VERSION_COUNT`)
- **Behavior:**
  1. When file update detected (checksum change):
     - Copy current file to `.horace_versions/<file_id>.v<N+1>`
     - Increment version counter in metadata
  2. When version count exceeds N:
     - Delete oldest version (`.v1`)
     - Shift remaining versions down (`.v2` → `.v1`, etc.)
  3. Version metadata includes: timestamp, size, checksum

**REQ-FR-004: Version Retrieval**
- **Description:** Restore or view previous file versions
- **Input:** File ID, version number (or "latest N")
- **Output:** Version metadata OR file path to version
- **Behavior:**
  1. Query PostgreSQL for version list
  2. Return metadata (timestamp, size, checksum, path)
  3. Optionally copy version to `/mnt/irina_storage/files/` (restore)

### 4.3 File Search and Discovery

**REQ-FR-005: Metadata Search**
- **Description:** Search files by metadata fields
- **Query Parameters:**
  - `tags`: List of tags (AND/OR logic)
  - `owner`: Component or user name
  - `created_after`, `created_before`: Date range
  - `file_type`: MIME type or extension
  - `min_size`, `max_size`: Size filters
  - `checksum`: Exact match (find duplicates)
- **Output:** List of matching file records (ID, path, metadata)
- **Performance:** <2 seconds for queries on 100,000+ files

**REQ-FR-006: Collections**
- **Description:** Group related files into named collections
- **Examples:**
  - "ICCM v3 Papers" - All paper revisions
  - "Architecture Diagrams" - All Playfair architecture diagrams
  - "User Manual Assets" - Documentation files
- **Operations:**
  - Create collection
  - Add/remove files
  - List collections
  - Get collection members

### 4.4 File Lifecycle

**REQ-FR-007: File Status Tracking**
- **Description:** Track file lifecycle state
- **States:**
  - `active` - Currently in use
  - `archived` - Retained but not actively used
  - `deleted` - Marked for deletion (soft delete)
- **Behavior:**
  1. Files default to `active` on registration
  2. `archived` files moved to `.horace_archive/` subdirectory
  3. `deleted` files removed from index after 30 days (configurable)

**REQ-FR-008: Duplicate Detection**
- **Description:** Identify duplicate files by checksum
- **Trigger:** Manual tool call OR during registration
- **Output:** List of files with identical SHA256 checksums
- **Use Case:** Prevent redundant storage of identical files

---

## 5. Storage Strategy

### 5.1 NFS Configuration (Irina Server)

**NFS Export Configuration** (`/etc/exports` on Irina):
```
/mnt/storage/iccm  192.168.1.0/24(rw,sync,no_subtree_check,no_root_squash)
```

**Rationale:**
- `rw` - Read-write access (containers can write files)
- `sync` - Synchronous writes (data integrity)
- `no_subtree_check` - Performance optimization
- `no_root_squash` - Allow Docker containers (running as root) to write

**Client Mount** (Pharaoh - in docker-compose.yml volumes):
```yaml
volumes:
  - type: volume
    source: irina_storage
    target: /mnt/irina_storage
    volume:
      nocopy: true
      driver_opts:
        type: nfs
        o: addr=192.168.1.210,rw,nfsvers=4
        device: ":/mnt/storage/iccm"
```

### 5.2 Samba/CIFS Configuration (Irina Server)

**Samba Share Configuration** (`/etc/samba/smb.conf` on Irina):
```ini
[iccm_storage]
   path = /mnt/storage/iccm
   browseable = yes
   read only = no
   guest ok = yes
   create mask = 0664
   directory mask = 0775
   # Windows file integrity (DeepSeek-R1 recommendation)
   strict sync = yes
   force create mode = 0664
   force directory mode = 0775
```

**Windows Access:**
- **UNC Path:** `\\192.168.1.210\iccm_storage`
- **Map Drive:** `net use Z: \\192.168.1.210\iccm_storage`
- **Authentication:** Guest (Phase 1), proper auth in Phase 2

### 5.3 Versioning Implementation

**Strategy: Horace-Managed Copy-on-Write**

When file updated (checksum changes):
```python
# Pseudocode with file locking (DeepSeek-R1 recommendation)
import fcntl

def create_version(file_id, current_path):
    # Get current version count
    version_count = get_version_count(file_id)
    next_version = version_count + 1

    # Acquire file lock for safe concurrent access
    with open(current_path, 'rb') as f:
        fcntl.flock(f, fcntl.LOCK_EX)

        # Copy current to version
        version_path = f".horace_versions/{file_id}.v{next_version}"
        shutil.copy2(current_path, version_path)

    # Store version metadata
    store_version_metadata(file_id, next_version, {
        'timestamp': now(),
        'size': file_size(current_path),
        'checksum': sha256(current_path),
        'path': version_path
    })

    # Prune old versions if count exceeds limit
    if version_count >= HORACE_VERSION_COUNT:
        delete_oldest_version(file_id)
```

**Version Pruning Policy:**
- Keep last `HORACE_VERSION_COUNT` versions (default: 5)
- Delete oldest when limit exceeded
- Never delete if file was created within last 7 days (safety)

**Restoration:**
```python
def restore_version(file_id, version_number):
    version_path = f".horace_versions/{file_id}.v{version_number}"
    current_path = get_current_path(file_id)

    # Create version of current before restoring
    create_version(file_id, current_path)

    # Copy version to current
    shutil.copy2(version_path, current_path)

    # Update metadata
    update_file_metadata(file_id, {'restored_from_version': version_number})
```

---

## 6. MCP Tools Specification

Horace provides **7 MCP tools** for file management:

**NOTE:** Version 2.0 adds `horace_restore_version` based on critical triplet feedback (Gemini-2.5-Pro): versioning feature was incomplete without programmatic restore capability.

### 6.1 `horace_register_file`

**Description:** Register a file with Horace catalog
**Category:** Core

**Parameters:**
```json
{
  "file_path": {
    "type": "string",
    "description": "Absolute path to file in /mnt/irina_storage/",
    "required": true,
    "example": "/mnt/irina_storage/files/gates/report_2025.odt"
  },
  "metadata": {
    "type": "object",
    "description": "File metadata",
    "required": true,
    "properties": {
      "owner": {
        "type": "string",
        "description": "Component or user who created file",
        "example": "gates"
      },
      "purpose": {
        "type": "string",
        "description": "What this file is for",
        "example": "ICCM v3 Paper - Architecture Overview"
      },
      "tags": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Search tags",
        "example": ["paper", "v3", "architecture"]
      },
      "collection": {
        "type": "string",
        "description": "Optional collection name",
        "example": "ICCM_v3_Papers"
      },
      "correlation_id": {
        "type": "string",
        "description": "Related conversation or Fiedler run",
        "example": "a1b2c3d4"
      }
    }
  }
}
```

**Returns:**
```json
{
  "file_id": "uuid-string",
  "checksum": "sha256-hash",
  "size": 12345,
  "mime_type": "application/vnd.oasis.opendocument.text",
  "registered_at": "2025-10-05T20:00:00Z",
  "version": 1
}
```

**Behavior:**
1. **Validate path** (DeepSeek-R1 security requirement):
   ```python
   if not file_path.startswith("/mnt/irina_storage/files/"):
       raise InvalidPathError("Path must be within /mnt/irina_storage/files/")
   if ".." in file_path:
       raise InvalidPathError("Path traversal not allowed")
   ```
2. Verify file exists at `file_path`
3. Compute SHA256 checksum
4. Detect MIME type from extension + magic bytes
5. Store in PostgreSQL `horace_files` table
6. Log registration to Godot
7. Return file metadata

**Error Cases:**
- Invalid path (outside `/mnt/irina_storage/files/` or contains `..`) → `InvalidPathError`
- File does not exist → `FileNotFoundError`
- File already registered (checksum match) → Return existing file_id

---

### 6.2 `horace_search_files`

**Description:** Search file catalog by metadata
**Category:** Core

**Parameters:**
```json
{
  "query": {
    "type": "object",
    "description": "Search filters",
    "properties": {
      "tags": {
        "type": "array",
        "items": {"type": "string"},
        "description": "Match files with ALL tags (AND logic)"
      },
      "owner": {
        "type": "string",
        "description": "Filter by owner (component or user)"
      },
      "created_after": {
        "type": "string",
        "format": "date-time",
        "description": "ISO 8601 timestamp"
      },
      "created_before": {
        "type": "string",
        "format": "date-time"
      },
      "file_type": {
        "type": "string",
        "description": "MIME type or extension",
        "example": "application/pdf OR .odt"
      },
      "min_size": {"type": "integer", "description": "Bytes"},
      "max_size": {"type": "integer", "description": "Bytes"},
      "collection": {
        "type": "string",
        "description": "Filter by collection name"
      },
      "status": {
        "type": "string",
        "enum": ["active", "archived", "deleted"],
        "default": "active"
      }
    }
  },
  "limit": {
    "type": "integer",
    "default": 50,
    "maximum": 1000,
    "description": "Max results to return"
  },
  "offset": {
    "type": "integer",
    "default": 0,
    "description": "Pagination offset"
  },
  "sort_by": {
    "type": "string",
    "enum": ["created_at", "updated_at", "size", "name"],
    "default": "created_at"
  },
  "order": {
    "type": "string",
    "enum": ["asc", "desc"],
    "default": "desc"
  }
}
```

**Returns:**
```json
{
  "total_count": 42,
  "results": [
    {
      "file_id": "uuid",
      "path": "/mnt/irina_storage/files/gates/...",
      "owner": "gates",
      "purpose": "...",
      "tags": ["paper", "v3"],
      "size": 12345,
      "mime_type": "application/pdf",
      "created_at": "2025-10-05T20:00:00Z",
      "updated_at": "2025-10-05T21:00:00Z",
      "version": 3,
      "checksum": "sha256-hash",
      "collection": "ICCM_v3_Papers"
    }
  ],
  "limit": 50,
  "offset": 0
}
```

---

### 6.3 `horace_get_file_info`

**Description:** Get detailed metadata for specific file
**Category:** Core

**Parameters:**
```json
{
  "file_id": {
    "type": "string",
    "description": "File UUID",
    "required": true
  },
  "include_versions": {
    "type": "boolean",
    "default": false,
    "description": "Include version history"
  }
}
```

**Returns:**
```json
{
  "file_id": "uuid",
  "path": "/mnt/irina_storage/files/gates/report.odt",
  "owner": "gates",
  "purpose": "ICCM v3 Architecture Paper",
  "tags": ["paper", "v3", "architecture"],
  "size": 12345,
  "mime_type": "application/vnd.oasis.opendocument.text",
  "created_at": "2025-10-05T20:00:00Z",
  "updated_at": "2025-10-05T21:30:00Z",
  "current_version": 3,
  "checksum": "sha256-hash",
  "collection": "ICCM_v3_Papers",
  "correlation_id": "a1b2c3d4",
  "status": "active",
  "versions": [
    {
      "version": 1,
      "timestamp": "2025-10-05T20:00:00Z",
      "size": 10000,
      "checksum": "sha256-v1",
      "path": ".horace_versions/uuid.v1"
    },
    {
      "version": 2,
      "timestamp": "2025-10-05T21:00:00Z",
      "size": 11500,
      "checksum": "sha256-v2",
      "path": ".horace_versions/uuid.v2"
    }
  ]
}
```

---

### 6.4 `horace_create_collection`

**Description:** Create or update a file collection
**Category:** Organization

**Parameters:**
```json
{
  "name": {
    "type": "string",
    "required": true,
    "description": "Collection name (unique)",
    "example": "ICCM_v3_Papers"
  },
  "description": {
    "type": "string",
    "description": "What this collection contains"
  },
  "file_ids": {
    "type": "array",
    "items": {"type": "string"},
    "description": "Initial files to add (UUIDs)"
  },
  "metadata": {
    "type": "object",
    "description": "Additional collection metadata"
  }
}
```

**Returns:**
```json
{
  "collection_id": "uuid",
  "name": "ICCM_v3_Papers",
  "description": "All paper files for ICCM v3 release",
  "file_count": 15,
  "created_at": "2025-10-05T20:00:00Z"
}
```

---

### 6.5 `horace_list_collections`

**Description:** List all collections
**Category:** Organization

**Parameters:**
```json
{
  "limit": {"type": "integer", "default": 50},
  "offset": {"type": "integer", "default": 0}
}
```

**Returns:**
```json
{
  "total_count": 5,
  "collections": [
    {
      "collection_id": "uuid",
      "name": "ICCM_v3_Papers",
      "description": "...",
      "file_count": 15,
      "created_at": "2025-10-05T20:00:00Z",
      "updated_at": "2025-10-05T21:00:00Z"
    }
  ]
}
```

---

### 6.6 `horace_update_file`

**Description:** Update file metadata or trigger re-versioning
**Category:** Core

**Parameters:**
```json
{
  "file_id": {
    "type": "string",
    "required": true
  },
  "metadata": {
    "type": "object",
    "description": "Metadata fields to update",
    "properties": {
      "tags": {"type": "array"},
      "purpose": {"type": "string"},
      "status": {"type": "string", "enum": ["active", "archived", "deleted"]},
      "collection": {"type": "string"}
    }
  },
  "check_for_changes": {
    "type": "boolean",
    "default": false,
    "description": "If true, recompute checksum and create version if changed"
  }
}
```

**Returns:**
```json
{
  "file_id": "uuid",
  "updated_fields": ["tags", "purpose"],
  "version_created": false,
  "current_version": 3
}
```

**Behavior:**
- Updates PostgreSQL metadata
- If `check_for_changes=true` and checksum differs → Create new version
- If `status=archived` → Move file to `.horace_archive/`
- If `status=deleted` → Mark for deletion (actual removal after 30 days)

---

### 6.7 `horace_restore_version`

**Description:** Restore a file to a previous version
**Category:** Core
**Added:** Version 2.0 (Critical triplet feedback - Gemini-2.5-Pro)

**Parameters:**
```json
{
  "file_id": {
    "type": "string",
    "description": "File UUID",
    "required": true
  },
  "version": {
    "type": "integer",
    "description": "Version number to restore",
    "required": true,
    "minimum": 1
  }
}
```

**Returns:**
```json
{
  "file_id": "uuid",
  "restored_to_version": 2,
  "new_version_created": 4,
  "current_path": "/mnt/irina_storage/files/gates/report.odt"
}
```

**Behavior:**
1. Verify version exists for the file
2. Create version of current state (safety backup before restore)
3. Copy specified version to current file location
4. Update metadata: `current_version` incremented, `restored_from_version` set
5. Log restoration event to Godot

**Error Cases:**
- File ID not found → `FileNotFoundError`
- Version number not found → `VersionNotFoundError`
- File locked by another process → `FileLockError`

**Example:**
```python
# User wants to restore version 2 of a document
result = horace_restore_version(
    file_id="abc123",
    version=2
)
# Current state (v4) is backed up as v5
# Version 2 is copied to current location
# Metadata updated: current_version=5, restored_from_version=2
```

---

## 7. Metadata Schema

### 7.1 PostgreSQL Tables

**Table: `horace_files`**
```sql
CREATE TABLE horace_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_path TEXT NOT NULL,
    owner TEXT NOT NULL,
    purpose TEXT,
    tags TEXT[] DEFAULT '{}',
    size BIGINT NOT NULL,
    mime_type TEXT,
    checksum TEXT NOT NULL,  -- SHA256
    status TEXT DEFAULT 'active' CHECK (status IN ('active', 'archived', 'deleted')),
    current_version INTEGER DEFAULT 1,
    collection_id UUID REFERENCES horace_collections(id),
    correlation_id TEXT,  -- Link to Fiedler run or conversation
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,  -- Soft delete timestamp
    metadata JSONB DEFAULT '{}'  -- Extensible metadata
);

CREATE INDEX idx_horace_files_owner ON horace_files(owner);
CREATE INDEX idx_horace_files_tags ON horace_files USING GIN(tags);
CREATE INDEX idx_horace_files_checksum ON horace_files(checksum);
CREATE INDEX idx_horace_files_status ON horace_files(status);
CREATE INDEX idx_horace_files_collection ON horace_files(collection_id);
CREATE INDEX idx_horace_files_created_at ON horace_files(created_at DESC);

-- Composite index for common search patterns (DeepSeek-R1 recommendation)
CREATE INDEX idx_horace_files_search ON horace_files
  (owner, status, created_at, mime_type);
```

**Table: `horace_versions`**
```sql
CREATE TABLE horace_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID REFERENCES horace_files(id) ON DELETE CASCADE,
    version INTEGER NOT NULL,
    size BIGINT NOT NULL,
    checksum TEXT NOT NULL,
    version_path TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(file_id, version)
);

CREATE INDEX idx_horace_versions_file ON horace_versions(file_id, version DESC);
```

**Table: `horace_collections`**
```sql
CREATE TABLE horace_collections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    metadata JSONB DEFAULT '{}'
);

CREATE INDEX idx_horace_collections_name ON horace_collections(name);
```

---

## 8. Integration Points

### 8.1 Gates Integration

**Gates Document Generation:**
```python
# After creating ODT document
output_path = f"/mnt/irina_storage/files/gates/{file_id}.odt"

# Write file
write_odt_to_path(markdown, output_path)

# Register with Horace
horace_register_file(
    file_path=output_path,
    metadata={
        "owner": "gates",
        "purpose": f"Generated from markdown: {title}",
        "tags": ["document", "odt", "gates"],
        "correlation_id": correlation_id,
        "collection": collection_name
    }
)
```

### 8.2 Playfair Integration

**Playfair Diagram Generation:**
```javascript
// After rendering diagram
const outputPath = `/mnt/irina_storage/files/playfair/${fileId}.svg`;

// Write diagram
fs.writeFileSync(outputPath, svgData);

// Register with Horace
await horace_register_file({
    file_path: outputPath,
    metadata: {
        owner: "playfair",
        purpose: `${diagramType} diagram - ${theme} theme`,
        tags: ["diagram", diagramType, format, theme],
        correlation_id: correlationId
    }
});
```

### 8.3 Fiedler Integration

**Fiedler LLM Output Storage:**
```python
# After LLM response
output_path = f"/mnt/irina_storage/files/fiedler/{correlation_id}_{model_id}.md"

# Write response
write_response(output_path, response_text)

# Register with Horace
horace_register_file(
    file_path=output_path,
    metadata={
        "owner": "fiedler",
        "purpose": f"LLM response from {model_id}",
        "tags": ["llm-output", model_id, "markdown"],
        "correlation_id": correlation_id
    }
)
```

### 8.4 User/Manual File Upload

**User-initiated file storage:**
```bash
# User copies file to storage
cp my_document.pdf /mnt/irina_storage/files/user/

# Register via MCP tool
horace_register_file(
    file_path="/mnt/irina_storage/files/user/my_document.pdf",
    metadata={
        "owner": "user",
        "purpose": "Project requirements document",
        "tags": ["requirements", "pdf", "user-upload"]
    }
)
```

---

## 9. Performance Requirements

### 9.1 File Registration

**REQ-PERF-001: Registration Latency**
- **Target:** <500ms for files <10MB
- **Target:** <2s for files 10MB-100MB
- **Target:** <10s for files 100MB-1GB
- **Includes:** Checksum computation, MIME detection, PostgreSQL insert

**REQ-PERF-002: Checksum Computation**
- **Algorithm:** SHA256
- **Streaming:** Read in 64KB chunks (memory-efficient)
- **Parallelism:** Single-threaded (I/O bound, not CPU bound)

### 9.2 Search Performance

**REQ-PERF-003: Search Latency**
- **Target:** <2s for queries on 100,000 files
- **Target:** <5s for complex queries (multiple filters + sorting)
- **Optimization:** PostgreSQL indexes on owner, tags (GIN), created_at, checksum

**REQ-PERF-004: Search Result Limits**
- **Default:** 50 results per page
- **Maximum:** 1,000 results per query
- **Pagination:** Offset-based (simple, predictable)

### 9.3 Versioning Performance

**REQ-PERF-005: Version Creation**
- **Target:** <1s for files <10MB
- **Method:** `shutil.copy2` (preserves timestamps, fast)
- **Concurrent Safety:** File locks during copy operations

**REQ-PERF-006: Version Pruning**
- **Trigger:** Asynchronous after version creation
- **Cleanup:** Delete oldest version if count > limit
- **Safety:** Never delete versions created within last 7 days

---

## 10. Security and Access Control

### 10.1 Phase 1 Security Model

**REQ-SEC-001: Network Isolation (Phase 1)**
- **Approach:** Trust Docker network (`iccm_network`)
- **Assumption:** All containers on `iccm_network` are trusted
- **No Authentication:** MCP tools callable by any component on network
- **No Authorization:** All files readable/writable by all components

**Rationale:** Phase 1 focuses on functionality. Proper authentication/authorization is Phase 2.

### 10.2 File System Security

**REQ-SEC-002: Path Validation**
- **Requirement:** All file paths MUST be within `/mnt/irina_storage/`
- **Validation:** Reject paths containing `..` or absolute paths outside mount
- **Error:** `InvalidPathError` if validation fails

**REQ-SEC-003: Checksum Verification**
- **Requirement:** Store SHA256 checksum for integrity verification
- **Use Case:** Detect file corruption or tampering
- **Future:** Validate checksum on file access (Phase 2)

### 10.3 Future Security Enhancements (Phase 2)

**REQ-SEC-004: Authentication (Phase 2)**
- **Mechanism:** API keys or JWT tokens for MCP tool access
- **Storage:** PostgreSQL `horace_api_keys` table
- **Validation:** Middleware layer before tool execution

**REQ-SEC-005: Authorization (Phase 2)**
- **Model:** Owner-based permissions (owner can read/write/delete, others read-only)
- **Implementation:** Check `owner` field in `horace_files` against caller identity
- **Admin Override:** Special "admin" role can access all files

---

## 11. Phase 1 Scope (MVP)

### 11.1 Included Features

**Core Functionality:**
✅ File registration with metadata
✅ Automatic versioning (last 5 versions)
✅ Metadata search by tags, owner, date, type, size
✅ Collections (create, list, add files)
✅ File info retrieval with version history
✅ Duplicate detection by checksum
✅ NFS mount for Linux containers
✅ Samba/CIFS export for Windows workstations
✅ PostgreSQL metadata storage (Winni)
✅ Godot logging integration
✅ 6 MCP tools (register, search, get_info, collections, update)

**Component Integration:**
✅ Gates writes ODT documents to Horace storage
✅ Playfair writes diagrams to Horace storage
✅ Fiedler writes LLM outputs to Horace storage

**Storage Features:**
✅ Organized directory structure by component
✅ Hidden `.horace_versions/` for version history
✅ Configurable version retention (default: 5)
✅ Automatic version pruning

### 11.2 Explicitly Excluded (Phase 2+)

❌ **Authentication/Authorization** - Trust network isolation in Phase 1
❌ **File Serving** - No HTTP/REST API for downloading files (use direct filesystem access)
❌ **Advanced Retention Policies** - No time-based expiration (e.g., "delete after 90 days")
❌ **Full-Text Search** - No content indexing (metadata-only search in Phase 1)
❌ **File Preview Generation** - No thumbnails or previews
❌ **Scheduled Scans** - Manual discovery only (no cron jobs)
❌ **Compression** - No automatic file compression
❌ **Encryption at Rest** - Filesystem-level encryption (outside Horace scope)

---

## 12. Phase 2+ Future Enhancements

### 12.1 Advanced Search

**Full-Text Content Search:**
- Index file content (text files, PDFs, ODT) using PostgreSQL `tsvector`
- Search within document text, not just metadata
- Weighted ranking (title > content)

**Advanced Query Syntax:**
- Boolean operators (AND, OR, NOT)
- Wildcard searches
- Fuzzy matching

### 12.2 Retention and Lifecycle Policies

**Time-Based Retention:**
- Auto-archive files after N days of inactivity
- Auto-delete archived files after N days
- Policy configuration per collection

**Smart Versioning:**
- Keep daily versions for last 7 days
- Keep weekly versions for last 4 weeks
- Keep monthly versions indefinitely

### 12.3 File Serving and Access

**HTTP REST API:**
- Download files via HTTP (Horace as content server)
- Streaming for large files
- Range requests for partial downloads

**Access Tokens:**
- Generate temporary signed URLs for file access
- Time-limited (e.g., expires in 1 hour)
- Revocable

### 12.4 Advanced Features

**File Relationships:**
- Track dependencies (e.g., diagram used in document)
- Version compatibility (which diagram version goes with which document version)

**Collaboration:**
- File locking (prevent concurrent edits)
- Change notifications (webhook when file updated)

**Analytics:**
- Storage usage by component
- Most accessed files
- Version churn metrics

---

## 13. Technical Specifications

### 13.1 Technology Stack

**Language:** Python 3.11
**Web Framework:** WebSocket server (websockets library)
**Database:** PostgreSQL 16+ (asyncpg)
**Filesystem:** NFS v4 client, Samba/CIFS (server-side on Irina)
**Logging:** Godot MCP client
**Container:** Docker (Alpine Linux base)

### 13.2 Dependencies

**Python Libraries:**
- `websockets>=14.0` - WebSocket MCP server
- `asyncpg>=0.29` - PostgreSQL async client
- `aiofiles>=23.0` - Async file I/O
- `python-magic>=0.4` - MIME type detection
- `pyyaml>=6.0` - Configuration
- Standard library: `hashlib`, `pathlib`, `shutil`, `json`

### 13.3 Configuration

**Environment Variables:**
```bash
# Database
HORACE_DB_HOST=192.168.1.210
HORACE_DB_PORT=5432
HORACE_DB_NAME=winni
HORACE_DB_USER=horace
HORACE_DB_PASSWORD=<secure-password>

# Storage
HORACE_STORAGE_PATH=/mnt/irina_storage
HORACE_VERSION_COUNT=5  # Number of versions to retain

# MCP Server
HORACE_MCP_PORT=8070  # Container port
HORACE_LOG_LEVEL=INFO

# Godot Logging
GODOT_MCP_URL=ws://godot-mcp:9060
```

### 13.4 Container Specifications

**Image:** `iccm/horace:latest`
**Base:** `python:3.11-alpine`
**Ports:**
- `9070:8070` (MCP WebSocket)

**Volumes:**
- `/mnt/irina_storage` - NFS mount (read-write)

**Resources:**
- **Memory:** 512MB (limit: 1GB)
- **CPU:** 1 core

**Network:** `iccm_network`

**Health Check:**
```yaml
healthcheck:
  test: ["CMD", "wget", "-q", "--spider", "http://localhost:8070/health"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 10s
```

---

## 14. Deployment

### 14.1 Prerequisites

**Irina Server Setup:**
1. **NFS Server Configuration:**
   ```bash
   # Install NFS server
   sudo apt-get install nfs-kernel-server

   # Create ICCM storage directory
   sudo mkdir -p /mnt/storage/iccm
   sudo chown -R nobody:nogroup /mnt/storage/iccm
   sudo chmod 777 /mnt/storage/iccm

   # Add export to /etc/exports
   echo "/mnt/storage/iccm  192.168.1.0/24(rw,sync,no_subtree_check,no_root_squash)" | sudo tee -a /etc/exports

   # Apply exports
   sudo exportfs -a
   sudo systemctl restart nfs-kernel-server
   ```

2. **Samba/CIFS Server Configuration:**
   ```bash
   # Install Samba
   sudo apt-get install samba

   # Add share to /etc/samba/smb.conf
   cat <<EOF | sudo tee -a /etc/samba/smb.conf
   [iccm_storage]
      path = /mnt/storage/iccm
      browseable = yes
      read only = no
      guest ok = yes
      create mask = 0664
      directory mask = 0775
   EOF

   # Restart Samba
   sudo systemctl restart smbd
   ```

3. **PostgreSQL User:**
   ```sql
   CREATE USER horace WITH PASSWORD '<secure-password>';
   GRANT ALL PRIVILEGES ON DATABASE winni TO horace;
   ```

**Pharaoh Client Setup:**
1. **Install NFS Client:**
   ```bash
   sudo apt-get install nfs-common
   ```

2. **Test Mount:**
   ```bash
   sudo mount -t nfs 192.168.1.210:/mnt/storage/iccm /tmp/test_mount
   ls /tmp/test_mount  # Should show iccm directory structure
   sudo umount /tmp/test_mount
   ```

### 14.2 Deployment Steps

**1. Create Database Schema:**
```bash
psql -h 192.168.1.210 -U horace -d winni -f /mnt/projects/ICCM/horace/schema.sql
```

**2. Build Docker Image:**
```bash
cd /mnt/projects/ICCM/horace
docker compose build
```

**3. Deploy Container:**
```bash
docker compose up -d horace-mcp
```

**4. Add to MCP Relay:**
```bash
# Via Claude Code MCP tools
mcp__iccm__relay_add_server(
    name="horace",
    url="ws://localhost:9070"
)
```

**5. Verify Deployment:**
```bash
# Check container health
docker ps --filter name=horace-mcp

# Check MCP tools available
# (Should see 6 Horace tools in Claude Code)

# Test file registration
horace_register_file(...)
```

---

## 15. Testing Requirements

### 15.1 Unit Tests

**File Registration:**
- ✅ Register new file → Success
- ✅ Register duplicate file (same checksum) → Return existing file_id
- ✅ Register file outside allowed path → Error
- ✅ Register non-existent file → Error

**Versioning:**
- ✅ Update file (checksum change) → Create version
- ✅ Update file (no checksum change) → No version created
- ✅ Exceed version limit → Oldest version deleted
- ✅ Restore from version → File content matches version

**Search:**
- ✅ Search by tags (AND logic) → Correct results
- ✅ Search by owner → Correct results
- ✅ Search by date range → Correct results
- ✅ Search with pagination → Correct offset/limit behavior

**Collections:**
- ✅ Create collection → Success
- ✅ Add files to collection → File count updated
- ✅ List collections → All collections returned

### 15.2 Integration Tests

**Gates Integration:**
- ✅ Gates writes ODT → File registered automatically
- ✅ Gates overwrites ODT → Version created
- ✅ Search for Gates documents → Found

**Playfair Integration:**
- ✅ Playfair writes SVG → File registered
- ✅ Search by diagram type tag → Found

**Fiedler Integration:**
- ✅ Fiedler writes LLM output → File registered
- ✅ Search by correlation_id → Found

### 15.3 Performance Tests

- ✅ Register 1,000 files → Average latency <500ms
- ✅ Search 100,000 files by tag → Latency <2s
- ✅ Create 10 versions of file → Latency <10s total
- ✅ List 1,000 collections → Latency <2s

### 15.4 End-to-End Tests

**Scenario: Full Document Workflow**
1. Gates generates ODT document
2. Document registered with Horace
3. User searches for document by tag
4. User retrieves document metadata
5. Gates updates document (new version)
6. User views version history
7. User restores previous version

**Expected:** All steps succeed, data consistent throughout

---

## 16. Open Questions for Triplet Review

1. **Versioning Strategy:** Is copy-on-write with last-N-versions retention sufficient, or should we use a more sophisticated approach (e.g., delta compression, ZFS snapshots)?

2. **Search Performance:** Are PostgreSQL GIN indexes + basic SQL queries sufficient for 100K+ files, or should we add full-text search (tsvector) in Phase 1?

3. **NFS vs. Object Storage:** Should Phase 2 consider S3-compatible object storage (MinIO) instead of NFS for better scalability?

4. **File Serving:** Should Horace provide HTTP download endpoints in Phase 1, or is direct filesystem access sufficient?

5. **Metadata Extensibility:** Is the JSONB `metadata` field sufficient for future custom fields, or should we design a more structured extension system?

6. **Concurrency:** Do we need file locking in Phase 1, or is optimistic concurrency (last-write-wins) acceptable?

7. **Collection Hierarchy:** Should collections support nesting (sub-collections), or is flat structure sufficient?

---

## 17. Success Criteria

Phase 1 MVP is successful when:

✅ **Functionality:**
- All 7 MCP tools operational
- File registration <500ms for typical files
- Search <2s for 10,000+ files
- Versioning working (last 5 versions retained)
- Collections working (create, list, search)

✅ **Integration:**
- Gates writes documents to Horace storage
- Playfair writes diagrams to Horace storage
- Fiedler writes LLM outputs to Horace storage
- All components use `/mnt/irina_storage/` mount

✅ **Cross-Platform Access:**
- Linux containers can read/write via NFS
- Windows workstations can access via `\\irina\iccm_storage`

✅ **Reliability:**
- Zero data loss during normal operations
- Graceful error handling (log and return error, don't crash)
- Container auto-restarts on failure

✅ **Logging:**
- All operations logged to Godot
- File registration, updates, searches, errors captured

---

## 18. Version 2.0 Changes (Triplet Feedback)

**Triplet Review:** Correlation ID `97a837cd` (2025-10-05)
**Models:** GPT-4o-mini, Gemini-2.5-Pro, DeepSeek-R1
**Verdict:** Unanimous approval with recommended changes applied

### 18.1 Critical Addition

**Issue:** Gemini-2.5-Pro identified missing restore functionality
**Change:** Added Section 6.7 `horace_restore_version` tool

**Rationale:** "The versioning feature is incomplete without a simple, programmatic way to restore a file to a previous version"

**Functionality:**
- Restore any previous version to current file location
- Creates safety backup before restoration
- Updates metadata with restoration event
- Logs to Godot for audit trail

### 18.2 Security Improvements

**Source:** DeepSeek-R1 recommendation
**Change:** Added path validation to `horace_register_file` (Section 6.1)

**Implementation:**
```python
if not file_path.startswith("/mnt/irina_storage/files/"):
    raise InvalidPathError("Path must be within /mnt/irina_storage/files/")
if ".." in file_path:
    raise InvalidPathError("Path traversal not allowed")
```

**Rationale:** Prevent directory traversal attacks and enforce storage boundaries

### 18.3 Performance Improvements

**Source:** DeepSeek-R1 recommendation
**Change:** Added composite index to PostgreSQL schema (Section 7.1)

**Implementation:**
```sql
CREATE INDEX idx_horace_files_search ON horace_files
  (owner, status, created_at, mime_type);
```

**Rationale:** Optimize common search patterns (e.g., "Find all Gates documents from last week")

### 18.4 Reliability Improvements

**Source:** DeepSeek-R1 recommendation
**Changes:**

1. **File Locking (Section 5.3):**
```python
import fcntl
with open(current_path, 'rb') as f:
    fcntl.flock(f, fcntl.LOCK_EX)
    # Copy current to version
```
**Rationale:** Prevent race conditions during concurrent versioning operations

2. **Samba Configuration (Section 5.2):**
```ini
strict sync = yes
force create mode = 0664
force directory mode = 0775
```
**Rationale:** Ensure Windows file writes are synchronized before reporting success

### 18.5 Consensus Achievements

All three triplet models unanimously agreed on:

1. ✅ **Architecture:** Option A (MCP control + direct NFS/Samba access) is the right choice
2. ✅ **Versioning:** Copy-on-write with last-5-versions retention is appropriate for this environment
3. ✅ **Storage Technology:** NFS + Samba dual-protocol approach is pragmatic and effective
4. ✅ **MCP Tools:** 7 tools (after adding restore) covers Phase 1 needs
5. ✅ **Metadata Schema:** PostgreSQL with JSONB extensibility is well-designed
6. ✅ **Phase 1 Scope:** Appropriate for "days to implement" goal
7. ✅ **Performance Targets:** Realistic and achievable with proposed architecture

### 18.6 Endorsements

**GPT-4o-mini:** "APPROVE - The proposed architecture is well-suited for the environment"

**Gemini-2.5-Pro:** "APPROVE WITH MINOR CHANGES - This is a textbook example of building the simplest thing that could possibly work"

**DeepSeek-R1:** "APPROVE with minor adjustments - The architecture is sound and aligns well with ICCM principles"

---

## End of Requirements Document

**Version:** 2.0 (Final - Triplet Consensus Approved)
**Status:** Ready for unanimous approval confirmation and implementation

**Next Steps:**
1. Final triplet approval confirmation on v2.0
2. Finalize requirements and archive
3. Implementation (Phase 1 MVP)

**Estimated Timeline:**
- Final approval: <1 day
- Implementation: 2-4 days (per ICCM development velocity)
- Testing and deployment: 1 day

**Total Phase 1 MVP:** 4-6 days estimated
